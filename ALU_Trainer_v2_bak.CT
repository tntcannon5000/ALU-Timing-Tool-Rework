<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="46">
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"Gearbox Info"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
// Target: Asphalt9_Steam_x64_rtl.exe
// Hook: RPM Write Instruction
// Opcode: movss [rdi+000001B8],xmm1
// Bytes: F3 0F 11 8F B8 01 00 00

aobscanmodule(INJECT_DASHBOARD,Asphalt9_Steam_x64_rtl.exe,F3 0F 11 8F B8 01 00 00)
alloc(newmem,$1000,INJECT_DASHBOARD)

label(code_dash)
label(returnhere_dash)

label(RaceRPM_Raw)
label(RaceRPM_Int)
label(RaceGear)

registersymbol(RaceRPM_Raw)
registersymbol(RaceRPM_Int)
registersymbol(RaceGear)
registersymbol(INJECT_DASHBOARD)

newmem:

  movss [rdi+000001B8],xmm1

  movss [RaceRPM_Raw], xmm1

  push rax
  cvttss2si eax, xmm1
  mov [RaceRPM_Int], eax
  pop rax

  push rax
  mov eax,[rdi+000000A0]
  mov [RaceGear],eax
  pop rax

  jmp returnhere_dash

code_dash:
  movss [rdi+000001B8],xmm1
  jmp returnhere_dash

RaceRPM_Raw:
  dd 0
RaceRPM_Int:
  dd 0
RaceGear:
  dd 0

INJECT_DASHBOARD:
  jmp newmem
  nop 3
returnhere_dash:

[DISABLE]

INJECT_DASHBOARD:
  db F3 0F 11 8F B8 01 00 00

unregistersymbol(RaceRPM_Raw)
unregistersymbol(RaceRPM_Int)
unregistersymbol(RaceGear)
unregistersymbol(INJECT_DASHBOARD)
dealloc(newmem)

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>1</ID>
          <Description>"RPM_Raw"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>Float</VariableType>
          <Address>RaceRPM_Raw</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>2</ID>
          <Description>"RPM"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>4 Bytes</VariableType>
          <Address>RaceRPM_Int</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>3</ID>
          <Description>"Gear"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>4 Bytes</VariableType>
          <Address>RaceGear</Address>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>4</ID>
      <Description>"Race Data (Timer + Progress)"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
// ---- Hook 1: Race Timer ----
// Instruction: add [rdi+000000A0],rax
// Bytes: 48 01 87 A0 00 00 00
aobscan(INJECT_RAW,48 01 87 A0 00 00 00)
alloc(newmem_timer,$1000,INJECT_RAW)

label(returnhere_timer)
label(RaceTimer)
registersymbol(RaceTimer)
registersymbol(INJECT_RAW)

newmem_timer:
  add [rdi+000000A0],rax

  push rbx
  mov rbx,[rdi+000000A0]
  mov [RaceTimer],ebx
  pop rbx

  jmp returnhere_timer

RaceTimer:
  dd 0

INJECT_RAW:
  jmp newmem_timer
  nop 2
returnhere_timer:

// ---- Hook 2: Race Progress ----
// Instruction: mov [rdi+000001D8],eax
// Bytes: 89 87 D8 01 00 00   +  48 83 C4 38 (signature context)
aobscanmodule(INJECT_PROGRESS,Asphalt9_Steam_x64_rtl.exe,89 87 D8 01 00 00 48 83 C4 38)
alloc(newmem_progress,$1000,INJECT_PROGRESS)

label(returnhere_progress)
label(RaceProgress)
registersymbol(RaceProgress)
registersymbol(INJECT_PROGRESS)

newmem_progress:
  mov [rdi+000001D8],eax

  push rbx
  mov ebx,[rdi+000001D8]
  mov [RaceProgress],ebx
  pop rbx

  jmp returnhere_progress

RaceProgress:
  dd 0

INJECT_PROGRESS:
  jmp newmem_progress
  nop
returnhere_progress:

[DISABLE]

INJECT_RAW:
  db 48 01 87 A0 00 00 00

INJECT_PROGRESS:
  db 89 87 D8 01 00 00

unregistersymbol(RaceTimer)
unregistersymbol(RaceProgress)
unregistersymbol(INJECT_RAW)
unregistersymbol(INJECT_PROGRESS)
dealloc(newmem_timer)
dealloc(newmem_progress)

</AssemblerScript>
      <CheatEntries>
        <CheatEntry>
          <ID>7</ID>
          <Description>"Race Time"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>4 Bytes</VariableType>
          <Address>RaceTimer</Address>
        </CheatEntry>
        <CheatEntry>
          <ID>8</ID>
          <Description>"Race Progress"</Description>
          <ShowAsSigned>0</ShowAsSigned>
          <VariableType>Float</VariableType>
          <Address>RaceProgress</Address>
        </CheatEntry>
      </CheatEntries>
    </CheatEntry>
    <CheatEntry>
      <ID>9</ID>
      <Description>"CP Finder"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
// 41 8B 85 4C 02 00 00 = mov eax,[r13+0000024C]
aobscanmodule(INJECT_CP,Asphalt9_Steam_x64_rtl.exe,41 8B 85 4C 02 00 00)
alloc(newmem_cp,$1000,INJECT_CP)

label(code_cp)
label(returnhere_cp)

label(Checkpoint)
registersymbol(Checkpoint)
registersymbol(INJECT_CP)

newmem_cp:

  push rdx
  lea rdx,[r13+0000024C]
  mov [Checkpoint],rdx
  pop rdx

code_cp:
  mov eax,[r13+0000024C]
  jmp returnhere_cp

Checkpoint:
  dq 0

INJECT_CP:
  jmp newmem_cp
  nop 2
returnhere_cp:

[DISABLE]
INJECT_CP:
  db 41 8B 85 4C 02 00 00

unregistersymbol(Checkpoint)
unregistersymbol(INJECT_CP)
dealloc(newmem_cp)

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>5</ID>
      <Description>"CP value"</Description>
      <ShowAsSigned>0</ShowAsSigned>
      <VariableType>4 Bytes</VariableType>
      <Address>Checkpoint</Address>
      <Offsets>
        <Offset>0</Offset>
      </Offsets>
    </CheatEntry>
    <CheatEntry>
      <ID>9000</ID>
      <Description>"ALU File Bridge (Python link)"</Description>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
{$lua}
if syntaxcheck then return end

local ALU_SEND_INTERVAL = 1
local ALU_DATA_PATH = os.getenv("TEMP") .. "\\alu_ce_bridge.dat"
local ALU_TMP_PATH  = ALU_DATA_PATH .. ".tmp"

ALU_pollTimer  = nil
ALU_statusForm = nil
ALU_statusLbl  = nil
ALU_writeCount = 0

ALU_statusForm = createForm(false)
ALU_statusForm.Caption     = "ALU File Bridge"
ALU_statusForm.Width       = 360
ALU_statusForm.Height      = 110
ALU_statusForm.Position    = "poScreenCenter"
ALU_statusForm.BorderStyle = "bsSingle"

ALU_statusLbl = createLabel(ALU_statusForm)
ALU_statusLbl.Caption  = "Starting..."
ALU_statusLbl.Left     = 12
ALU_statusLbl.Top      = 12
ALU_statusLbl.AutoSize = true

local pathLbl = createLabel(ALU_statusForm)
pathLbl.Caption  = "File: " .. ALU_DATA_PATH
pathLbl.Left     = 12
pathLbl.Top      = 36
pathLbl.AutoSize = true

function ALU_stop()
  if ALU_pollTimer then
    ALU_pollTimer.Enabled = false
    ALU_pollTimer.destroy()
    ALU_pollTimer = nil
  end
  pcall(os.remove, ALU_DATA_PATH)
  pcall(os.remove, ALU_TMP_PATH)
  if ALU_statusForm then
    ALU_statusForm.destroy()
    ALU_statusForm = nil
    ALU_statusLbl  = nil
  end
  print("[ALU Bridge] Stopped")
end

local stopBtn = createButton(ALU_statusForm)
stopBtn.Caption = "Stop"
stopBtn.Left    = 12
stopBtn.Top     = 64
stopBtn.Width   = 80
stopBtn.OnClick = ALU_stop

ALU_statusForm.OnClose = function()
  ALU_stop()
  return caFree
end

ALU_statusForm.Show()

function ALU_readGameValues()
  local timerVal    = 0
  local progressVal = 0.0
  local rpmInt      = 0
  local gearVal     = 0
  local rpmRaw      = 0.0
  local cpVal       = 0

  local a1 = getAddressSafe("RaceTimer")
  if a1 and a1 ~= 0 then timerVal = readInteger(a1) or 0 end

  local a2 = getAddressSafe("RaceProgress")
  if a2 and a2 ~= 0 then progressVal = readFloat(a2) or 0.0 end

  local a3 = getAddressSafe("RaceRPM_Int")
  if a3 and a3 ~= 0 then rpmInt = readInteger(a3) or 0 end

  local a4 = getAddressSafe("RaceGear")
  if a4 and a4 ~= 0 then gearVal = readInteger(a4) or 0 end

  local a5 = getAddressSafe("RaceRPM_Raw")
  if a5 and a5 ~= 0 then rpmRaw = readFloat(a5) or 0.0 end

  local a6 = getAddressSafe("Checkpoint")
  if a6 and a6 ~= 0 then
    local ptr = readQword(a6)
    if ptr and ptr ~= 0 then cpVal = readInteger(ptr) or 0 end
  end

  return timerVal, progressVal, rpmInt, gearVal, rpmRaw, cpVal
end

function ALU_writeToFile()
  local t, p, rpm, gear, rpmRaw, cp = ALU_readGameValues()

  local f = io.open(ALU_TMP_PATH, "w")
  if f then
    f:write(string.format("%d|%.6f|%d|%d|%.6f|%d", t, p, rpm, gear, rpmRaw, cp))
    f:close()
    os.remove(ALU_DATA_PATH)
    os.rename(ALU_TMP_PATH, ALU_DATA_PATH)

    ALU_writeCount = ALU_writeCount + 1
    if ALU_writeCount % 100 == 0 and ALU_statusLbl then
      ALU_statusLbl.Caption = string.format(
        "T=%d  P=%.1f%%  RPM=%d  G=%d  CP=%d  (#%d)",
        t, p * 100, rpm, gear, cp, ALU_writeCount)
    end
  end
end

ALU_pollTimer = createTimer(nil, false)
ALU_pollTimer.Interval = ALU_SEND_INTERVAL
ALU_pollTimer.OnTimer  = ALU_writeToFile
ALU_pollTimer.Enabled  = true

if ALU_statusLbl then ALU_statusLbl.Caption = "Running -- waiting for values..." end
print("[ALU Bridge] Writing to: " .. ALU_DATA_PATH)


[DISABLE]
{$lua}
if syntaxcheck then return end

if ALU_pollTimer then
  ALU_pollTimer.Enabled = false
  ALU_pollTimer.destroy()
  ALU_pollTimer = nil
end
pcall(os.remove, os.getenv("TEMP") .. "\\alu_ce_bridge.dat")
pcall(os.remove, os.getenv("TEMP") .. "\\alu_ce_bridge.dat.tmp")
if ALU_statusForm then
  ALU_statusForm.destroy()
  ALU_statusForm = nil
  ALU_statusLbl  = nil
end
print("[ALU Bridge] Stopped")

      </AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
  <LuaScript>--[[
  ALU Trainer -- Auto-attach and Auto-enable
  On load:
    1. Scans for a running process containing "asphalt" in name
    2. Attaches CE to it
    3. Enables: Gearbox Info, Race Data, CP Finder, ALU File Bridge
  If game not running yet, re-checks every 2 seconds.
]]

local SCRIPT_IDS      = {0, 4, 9, 9000}
local POLL_MS         = 2000
local ENABLE_DELAY_MS = 2000

ALU_scanTimer = nil

function ALU_findAsphalt()
  local pid = nil
  local pname = nil

  local ok, err = pcall(function()
    local sl = createStringlist()
    getProcessList(sl)
    for i = 0, sl.Count - 1 do
      local entry = sl[i]
      if entry and string.find(string.lower(entry), "asphalt") then
        local h = string.match(entry, "^(%x+)")
        if h then
          pid = tonumber(h, 16)
          pname = string.match(entry, "^%x+%-(.+)$")
        end
        break
      end
    end
    sl.destroy()
  end)

  if not ok then
    print("[ALU] Process scan error: " .. tostring(err))
  end

  return pid, pname
end

function ALU_enableScripts()
  local al = getAddressList()
  for _, id in ipairs(SCRIPT_IDS) do
    local mr = al.getMemoryRecordByID(id)
    if mr then
      local ok2, err2 = pcall(function() mr.Active = true end)
      if ok2 then
        print("[ALU] Enabled: " .. mr.Description)
      else
        print("[ALU] FAILED to enable ID " .. id .. ": " .. tostring(err2))
      end
    else
      print("[ALU] WARNING: script ID " .. id .. " not found")
    end
  end
  print("[ALU] All scripts activated.")
end

function ALU_attach()
  local pid, name = ALU_findAsphalt()
  if pid then
    print("[ALU] Found: " .. tostring(name) .. " (PID " .. pid .. ")")
    openProcess(pid)

    -- Delay to let CE finish attaching and resolve modules
    local t = createTimer(nil, false)
    t.Interval = ENABLE_DELAY_MS
    t.OnTimer = function(sender)
      sender.Enabled = false
      sender.destroy()
      ALU_enableScripts()
    end
    t.Enabled = true
    return true
  end
  return false
end

-- Try immediately, then poll if needed
if not ALU_attach() then
  print("[ALU] Waiting for Asphalt process...")
  ALU_scanTimer = createTimer(nil, false)
  ALU_scanTimer.Interval = POLL_MS
  ALU_scanTimer.OnTimer = function(sender)
    if ALU_attach() then
      sender.Enabled = false
      sender.destroy()
      ALU_scanTimer = nil
    end
  end
  ALU_scanTimer.Enabled = true
end
</LuaScript>
</CheatTable>
